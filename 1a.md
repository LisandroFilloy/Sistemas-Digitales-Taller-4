#
main:       
            li s1, 2024 // guarda en el registro s1 el inmediato 2024
            mv a0, s1 // guarda en el registro a0 el valor del registro s1, a0 <- 2024
            jal, ra FUNCION // salta a la instruccion de la etiqueta FUNCION y guarda la posicion de memoria actual en el registro ra
            add a0, s1, a0 // a0 <- s1 + a0
            bnez a0, noFunciona // salta si a0 != 0
funciona:   
            li a1, 1 // a1 <- 1
            j fin // salta a fin 
noFunciona: 
            li a1, 0 // a1 <- 0
fin:        
            j fin // Termina el programa -> bucle infinito en esta posicion de memoria

#
FUNCION:    
            addi sp, sp, -4 // sp <- sp-4
            sw ra (0)sp // almacenar la direccion de retorno en el stack
            not s1, a0 // carga en s1 el valor de a0 invertiod
            addi a0, s1, 1 // a0 <- s1 + 1
            lw ra, (0)sp // carga en el valor de sp-4 (memoria)
            addi sp, sp, 4 // vuelve el stack pointer a su valor original (preservacion correcta)
            ret 


Funcion:
- preserva el stack pointer
- usa la posicion de memoria SP-4 para guardar ra y luego lo vuelve a cargar (no tiene efecto). 
- asigna a a0 el inverso en complemento a 2 de si mismo, utilizando el registro s1 durante el proceso.
- no preserva el valor de s1 (lo cual es erroneo), dejandolo en -2025.

Nombre: Invertir (invierte en complemento a 2, aunque erroneamente no cumple el contrato ABI)

#
prologo: 1-2 
epilogo: 5-7

# 
El unico error es de parte del programador A, quien no preservo el valor de s1 en el codigo de la funcion.

# 
Para arreglar la funcion, debemos agregar codigo que preserve s1. Para ello podemos usar algun registro libre como t0, que no debe ser preservado, en reemplazo de s1. 